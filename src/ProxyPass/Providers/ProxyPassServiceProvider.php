<?php

namespace CSUNMetaLab\ProxyPass\Providers;

use Illuminate\Support\ServiceProvider;

use Config;
use URL;

class ProxyPassServiceProvider extends ServiceProvider
{
	public function register() {
		
	}

	public function boot() {
		$this->publishes([
        	__DIR__.'/../config/proxypass.php' => config_path('proxypass.php'),
    	]);

        if(Config::get('proxypass.proxy_active')) {
            // if we already have a URL forced via the .env file, don't attempt
            // to configure the root URL from the proxy headers
            $url_override = config('proxypass.public_url_override');
            if(empty($url_override)) {
                // only configure overrides based upon whether the proxy is
                // allowed to perform proxy operations
                if($this->canProxy()) {
                    $this->configureProxiedURLs();
                }
            }

            // force the root URL and the schema based on the configuration
            // values generated by the .env file or the proxy headers
            $this->forceProxiedURLs();
        }
	}

    /**
     * Returns whether the proxy server is allowed to perform proxy operations
     * and affect how the URLs are generated.
     *
     * @return bool
     */
    private function canProxy() {
        // grab the comma-delimited set of trusted proxies if they exist
        $trustedProxies = Config::get('proxypass.trusted_proxies');
        if(empty($trustedProxies)) {
            // no proxies have been whitelisted so allow all proxy servers
            return true;
        }

        // form an array and kill any whitespace in each element
        $proxyArr = explode(",", $trustedProxies);
        array_walk($proxyArr, 'trim');

        // first we need to check the REMOTE_ADDR value to see if the IP
        // address being reported matches one of the trusted proxies
        if(!empty($_SERVER['REMOTE_ADDR'])) {
            if(in_array($_SERVER['REMOTE_ADDR'], $proxyArr)) {
                // the machine that made the request is a trusted proxy so
                // everything is fine
                return true;
            }
        }

        // now we need to check the X-Forwarded-Server header if it exists
        // since that's one of the three standard request headers that a
        // proxy would pass along with a request
        if(!empty($_SERVER['HTTP_X_FORWARDED_SERVER'])) {
            if(in_array(trim($_SERVER['HTTP_X_FORWARDED_SERVER']), $proxyArr)) {
                // the hostname of the proxy matches a trusted proxy so
                // everything is fine
                return true;
            }
        }

        // we are either not behind a proxy or the proxy forwarding the request
        // is not in the set of trusted proxies
        return false;
    }

    /**
     * Sets the overrides for the global scheme and base URL based on the
     * headers received from the proxy server. 
     */
	private function configureProxiedURLs() {
        $urlOverride = "";
        $proxyHeader = Config::get(
        	'proxypass.proxy_path_header', 'HTTP_X_FORWARDED_PATH');
     
        // check the explicit path header (default is 'HTTP_X_FORWARDED_PATH') for rewrite purposes; this
        // header can take both regular subdomain hosting as well as a path within
        // a subdomain into account
        $forwardedPath = (!empty($_SERVER[$proxyHeader]) ? $_SERVER[$proxyHeader] : "");
        if(!empty($forwardedPath)) {
            $urlOverride = $forwardedPath;
        }
     
        // should there also be a schema override for HTTPS?
        $schemaOverride = "";
        if(!empty($_SERVER['SERVER_PORT'])) {
            // check port as a first attempt
            $schemaOverride = ($_SERVER['SERVER_PORT'] == '443' ? "https" : "");
        }
        if(!empty($_SERVER['HTTP_X_FORWARDED_PROTO'])) {
            // check standard LB request header
            $schemaOverride = ($_SERVER['HTTP_X_FORWARDED_PROTO'] == "https" ? "https" : "");
        }
        if(!empty($urlOverride)) {
            // does the schema of the URL override begin with https?
            if(starts_with($urlOverride, 'https')) {
                // set the schema override explicitly because the URL override
                // in URL::forceRootUrl() does not take schema into account
                $schemaOverride = "https";
            }
        }
        if(!empty($schemaOverride)) {
            Config::set('proxypass.public_schema_override', $schemaOverride);
        }
     
        // if we now have a URL override, set it
        if(!empty($urlOverride)) {
            if($schemaOverride == "https") {
                // override the root URL to include HTTPS as well
                Config::set('proxypass.public_url_override',
                    str_replace('http:', 'https:', $urlOverride));
            }
            else
            {
                Config::set('proxypass.public_url_override', $urlOverride);
            }
        }
	}

    /**
     * Applies any set overrides for the global scheme and base URL. These
     * overrides can come either from existing Laravel configuration or
     * from the proxy itself.
     */
	private function forceProxiedURLs() {
		// override the public schema if an override exists
        $publicSchema = config("proxypass.public_schema_override");
        if(!empty($publicSchema)) {
            if(method_exists('Illuminate\Routing\UrlGenerator', 'forceScheme')) {
                // method name changed in Laravel 5.4
                URL::forceScheme($publicSchema);
            }
            else
            {
                // Laravel version prior to 5.4
                URL::forceSchema($publicSchema);
            }
        }

        // override the public root URL if an override exists
        $publicOverride = config("proxypass.public_url_override");
        if(!empty($publicOverride)) {
            URL::forceRootUrl($publicOverride);
        }
	}
}